[
["index.html", "Data Analysis Notes Chapter 1 Introduction", " Data Analysis Notes Jeffrey B. Arnold 2017-03-07 Chapter 1 Introduction Notes used when teaching “POLS/CS&amp;SS 501: Advanced Political Research Design and Analysis” and “POLS/CS&amp;SS 503: Advanced Quantitative Political Methodology” at the University of Washington. \\[ \\] "],
["part-linear-models.html", "Chapter 2 (PART) Linear Models", " Chapter 2 (PART) Linear Models "],
["marginal-effects.html", "Chapter 3 Marginal Effects 3.1 References", " Chapter 3 Marginal Effects Let’s start with what it that we want to calculate. We want to calculate the “marginal effect” of changing the \\(j\\)th predictors while holding other predictors constant. \\[ ME_j = E( y | x_j, x_{-j}) - E( y | x_j + \\Delta x, x_{-j}) \\] or for a small change, \\(\\Delta x_j \\to 0\\) in a continuous \\(x_j\\), this is the partial derivative, \\[ ME_j = \\frac{\\partial E( y | x_j, x_{-j})}{\\partial x_j} \\] Now consider the linear regression with two predictors for a change in \\(x_1\\), \\[ \\begin{aligned}[t] ME_j &amp;= E(y | x_1, \\tilde{x}_2) - E(y | x_1 + \\Delta, \\tilde{x}_2) \\end{aligned} \\] Since the linear regression equation is \\(E(y | x)\\), this simplifies to \\[ \\begin{aligned}[t] ME_j &amp;= (\\beta_0 + \\beta_1 x_1 + \\tilde{x}_2) - (\\beta_0 + \\beta_1 (x_1 + \\Delta) \\tilde{x}_2) \\\\ &amp;= \\beta_1 \\Delta \\end{aligned} \\] or with \\(\\Delta \\to 0\\), \\[ \\begin{aligned}[t] ME_j &amp;= \\frac{\\partial E(y | x_1, x_2)}{\\partial x_1} \\\\ \\frac{\\partial (\\beta_0 + \\beta_1 x_1 + \\tilde{x}_2)}{\\partial x_1} &amp;= \\beta_1 \\end{aligned} \\] Note that those equations were on the population level \\[ \\hat{ME}_j &amp;= \\hat{\\beta_1} \\] So, for a linear regression, the marginal effect of \\(x_j\\), defined as the change in the expected value of \\(y\\) for a small a unit of \\(j\\) The equation presented above is not causal, it is simply a function derived from the population or estimated equation. If population equation is not the as the linear regressionthen \\(\\hat{\\beta_j}\\) can still be viewed as an estimator of \\(ME_j\\). It is like the \\(ME_j\\) weighted by observations with the most variation in \\(x_j\\), after accounting for the parts of \\(x_j\\) and \\(y\\) predicted by the other predictors. See the discussion in Agresti and Pischke. For regressions other than OLS, the coefficients are not the \\(ME_j\\). It is a luxury that the coefficients happen to have a nice interpretation in OLS. In most other regressions, the coefficients are not directly useful. The researcher should estimate what is of interest. Even for OLS, if \\(x_j\\) is included as part of a function, e.g. a polynomial or an interaction, then its coefficient cannot be interpreted as the marginal effect. Suppose the regression equation is, \\[ y = \\beta_0 + \\beta_1 x_1 + \\beta_2 x_1^2 + \\beta_3 x_2, \\] then the marginal effect of \\(x_1\\) is, \\[ \\begin{aligned}[t] ME_j &amp;= \\frac{\\partial E(y | x_1, x_2)}{\\partial x_1} \\\\ \\frac{\\partial (\\beta_0 + \\beta_1 x_1 + \\beta_1 x_1^2 + \\beta_3 \\tilde{x}_2)}{\\partial x_1} &amp;= \\beta_1 + 2 \\beta_2 x_1 \\end{aligned} \\] Note that the marginal effect of \\(x_1\\) is not, \\(\\beta_1\\). That would require a change in \\(x_1\\) while holding \\(x_1 ^ 2\\) constant, which is a logical impossibility. Instead, the marginal effect of \\(x_1\\) depends on the value of \\(x_2\\) at which it is evaluated. Similarly is there is an interaction between \\(x_1\\) and \\(x_2\\), \\[ y = \\beta_0 + \\beta_1 x_1 + \\beta_2 x_1 + \\beta_3 x_1 x_2 \\] then the marginal effect of \\(x_1\\) is, \\[ \\begin{aligned}[t] ME_j &amp;= \\frac{\\partial E(y | x_1, x_2)}{\\partial x_1} \\\\ \\frac{\\partial (\\beta_0 + \\beta_1 x_1 + \\beta_1 x_1^2 + \\beta_2 \\tilde{x}_2)}{\\partial x_1} &amp;= \\beta_1 + \\beta_3 x_2 \\end{aligned} \\] Now the marginal effect of \\(x_1\\) id a function of the value(s) of \\(x_2\\). For marginal effects that are functions of the data, there are multiple ways to calculate them. They include, AME: Average Marginal Effect. Average the marginal effects at each observed \\(x\\). MEM: Marginal Effect at the mean. Calculate the marginal effect with all observations at their means or other central values. MER: Marginal Effect at a representative value. Similar to MEM but with another meaningful value. Of these, the AME is the preferred one; MEM is an approximation. When it is discrete change in \\(x\\), it is called a partial effect (APE) or a first difference. The difference in the expected value of y, given a change in \\(x_j\\) from \\(x^*\\) to \\(x^* + \\Delta\\) is \\(\\beta_j \\Delta\\), and the standard error can be calculated analytically by https://en.wikipedia.org/wiki/Delta_method, \\[ se(\\hat{beta}_j \\Detlta) = \\sqrt{Var\\hat{beta_j} \\Delta^2} = \\se\\hat{beta_j} \\Delta . \\] The Delta method can be used to analytically derive approximations of the standard errors for other nonlinear functions and interaction in regression, but it scales poorly, and it is often easier to use bootstrapping or software than calculate it by hand. See the margins package. 3.1 References Cameron, Trivedi, “Microeconomics Using Stata” Ch 10. Agresti and Pischke etc. "],
["many-models.html", "Chapter 4 Many Models 4.1 Prerequisites 4.2 Programming with Formulas 4.3 Programming with Formulas", " Chapter 4 Many Models These notes build off of the topics discussed in the chapter Many Models in R for Data Science. It uses functionals (map() function) for iteration, string functions, and list columns in data frames. 4.1 Prerequisites library(&quot;tidyverse&quot;) library(&quot;stringr&quot;) library(&quot;broom&quot;) 4.2 Programming with Formulas In these examples, we’ll use the car dataset in the car package. Prestige &lt;- car::Prestige Each observation is an occupation, and contains the prestige score of the occupation from a survey, and the average education, income, percentage of women, and type of occumpation. glimpse(Prestige) ## Observations: 102 ## Variables: 6 ## $ education &lt;dbl&gt; 13.11, 12.26, 12.77, 11.42, 14.62, 15.64, 15.09, 15.... ## $ income &lt;int&gt; 12351, 25879, 9271, 8865, 8403, 11030, 8258, 14163, ... ## $ women &lt;dbl&gt; 11.16, 4.02, 15.70, 9.11, 11.68, 5.13, 25.65, 2.69, ... ## $ prestige &lt;dbl&gt; 68.8, 69.1, 63.4, 56.8, 73.5, 77.6, 72.6, 78.1, 73.1... ## $ census &lt;int&gt; 1113, 1130, 1171, 1175, 2111, 2113, 2133, 2141, 2143... ## $ type &lt;fctr&gt; prof, prof, prof, prof, prof, prof, prof, prof, pro... We will run several regressions with prestige as the outcome variable, and the over variables are explanatory variables. 4.3 Programming with Formulas In R, the formulas are objects (of class &quot;formula&quot;). That means we can program on them, and importantly, perhaps avoid excessive copying and pasting if we run multiple models. A formula object is created with the ~ operator: f &lt;- prestige ~ type + education class(f) ## [1] &quot;formula&quot; f ## prestige ~ type + education A useful function for working with formulas is update. The update function allows you to easiy # the . is replaced by the original formula values update(f, . ~ income) ## prestige ~ income update(f, income ~ .) ## income ~ type + education update(f, . ~ . + type + women) ## prestige ~ type + education + women Also note that many types of models have update method which will rerun the model with a new formula. Sometimes this can help computational time if the model is able to reuse some previous results or data. You can also create formulae from a character vector as.formula(&quot;prestige ~ income + education&quot;) ## prestige ~ income + education This means that you can create model formulae programmatically which is useful if you are running many models, or simply to keep the logic of your code clear. xvars &lt;- c(&quot;type&quot;, &quot;income&quot;, &quot;education&quot;) as.formula(str_c(&quot;prestige&quot;, &quot;~&quot;, str_c(xvars, collapse = &quot; + &quot;))) ## prestige ~ type + income + education Often you will need to run multiple models. Since most often the only thing that changes between models is the formula (the outcome or response variables), storing the formula in a list, and then running the models by iterating through the list is a clean strategy for estimating your models. xvar_list &lt;- list(c(&quot;type&quot;), c(&quot;income&quot;), c(&quot;education&quot;), c(&quot;type&quot;, &quot;income&quot;), c(&quot;type&quot;, &quot;income&quot;, &quot;education&quot;)) formulae &lt;- vector(&quot;list&quot;, length(xvar_list)) for (i in seq_along(xvar_list)) { formulae[[i]] &lt;- str_c(&quot;prestige ~ &quot;, str_c(xvar_list[[i]], collapse = &quot; + &quot;)) } formulae ## [[1]] ## [1] &quot;prestige ~ type&quot; ## ## [[2]] ## [1] &quot;prestige ~ income&quot; ## ## [[3]] ## [1] &quot;prestige ~ education&quot; ## ## [[4]] ## [1] &quot;prestige ~ type + income&quot; ## ## [[5]] ## [1] &quot;prestige ~ type + income + education&quot; Alternatively, create this list of formulae with a functional, make_mod_f &lt;- function(x) { str_c(&quot;prestige ~ &quot;, str_c(x, collapse = &quot; + &quot;)) } formulae &lt;- map(xvar_list, make_mod_f) Now that we have the various model formulae we want to run, we can Run a single model that returns a data frame with a single row and column: mod: a list column with lm object with the fitted model. I set model = FALSE because by default an lm model stores the data used to estimte it. This is convenient, but if you are estimating many models, it can start taking up space. run_reg &lt;- function(f) { mod &lt;- lm(f, data = Prestige, model = FALSE) data_frame(mod = list(mod)) } ret &lt;- run_reg(formulae[[1]]) ret[[&quot;mod&quot;]][[1]] ## ## Call: ## lm(formula = f, data = Prestige, model = FALSE) ## ## Coefficients: ## (Intercept) typeprof typewc ## 35.527 32.321 6.716 It doesn’t make much sense to store that as a data frame on its own, but with multiple inputs it will be useful. Now, run run_reg for each formula in formulae using map_df to return the results as a data frame with a list column, mod, containing the lm objects. prestige_fits &lt;- map_df(formulae, run_reg, .id = &quot;.id&quot;) prestige_fits ## # A tibble: 5 × 2 ## .id mod ## &lt;chr&gt; &lt;list&gt; ## 1 1 &lt;S3: lm&gt; ## 2 2 &lt;S3: lm&gt; ## 3 3 &lt;S3: lm&gt; ## 4 4 &lt;S3: lm&gt; ## 5 5 &lt;S3: lm&gt; From here, it is easy to extract parts of the models that. To extract the original formulas and add them to the data set, run formula() on each lm object using map, and then convert it to a character string using deparse: prestige_fits &lt;- prestige_fits %&gt;% mutate(formula = map_chr(mod, ~ deparse(formula(.x)))) prestige_fits$formula ## [1] &quot;prestige ~ type&quot; ## [2] &quot;prestige ~ income&quot; ## [3] &quot;prestige ~ education&quot; ## [4] &quot;prestige ~ type + income&quot; ## [5] &quot;prestige ~ type + income + education&quot; Get a data frame of the coefficients for all models using tidy and unnest: mutate(prestige_fits, x = map(mod, tidy)) %&gt;% unnest(x) ## # A tibble: 16 × 7 ## .id formula term estimate ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 prestige ~ type (Intercept) 35.527272727 ## 2 1 prestige ~ type typeprof 32.321114370 ## 3 1 prestige ~ type typewc 6.716205534 ## 4 2 prestige ~ income (Intercept) 27.141176368 ## 5 2 prestige ~ income income 0.002896799 ## 6 3 prestige ~ education (Intercept) -10.731981968 ## 7 3 prestige ~ education education 5.360877731 ## 8 4 prestige ~ type + income (Intercept) 27.997056941 ## 9 4 prestige ~ type + income typeprof 25.055473883 ## 10 4 prestige ~ type + income typewc 7.167155112 ## 11 4 prestige ~ type + income income 0.001401196 ## 12 5 prestige ~ type + income + education (Intercept) -0.622929165 ## 13 5 prestige ~ type + income + education typeprof 6.038970651 ## 14 5 prestige ~ type + income + education typewc -2.737230718 ## 15 5 prestige ~ type + income + education income 0.001013193 ## 16 5 prestige ~ type + income + education education 3.673166052 ## # ... with 3 more variables: std.error &lt;dbl&gt;, statistic &lt;dbl&gt;, ## # p.value &lt;dbl&gt; Get a data frame of model summary statistics for all models using glance, mutate(prestige_fits, x = map(mod, glance)) %&gt;% unnest(x) ## # A tibble: 5 × 14 ## .id mod formula r.squared ## &lt;chr&gt; &lt;list&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 &lt;S3: lm&gt; prestige ~ type 0.6976287 ## 2 2 &lt;S3: lm&gt; prestige ~ income 0.5110901 ## 3 3 &lt;S3: lm&gt; prestige ~ education 0.7228007 ## 4 4 &lt;S3: lm&gt; prestige ~ type + income 0.7764569 ## 5 5 &lt;S3: lm&gt; prestige ~ type + income + education 0.8348574 ## # ... with 10 more variables: adj.r.squared &lt;dbl&gt;, sigma &lt;dbl&gt;, ## # statistic &lt;dbl&gt;, p.value &lt;dbl&gt;, df &lt;int&gt;, logLik &lt;dbl&gt;, AIC &lt;dbl&gt;, ## # BIC &lt;dbl&gt;, deviance &lt;dbl&gt;, df.residual &lt;int&gt; "],
["coming-to-r-from-other-languages.html", "Chapter 5 Coming to R from other Languages 5.1 Stata", " Chapter 5 Coming to R from other Languages 5.1 Stata There are not as many of these as I would have expected. These are the only useful ones that I found. Matthieu Gomez “R for Stata Users”. http://www.princeton.edu/~mattg/statar/ EconometricsBySimulation. “Dictionary: Stata to R” https://github.com/EconometricsBySimulation/RStata/wiki/Dictionary:-Stata-to-R DataCamp course *R for SAS, SPSS and Stata Users“. https://www.datacamp.com/courses/r-for-sas-spss-and-stata-users-r-tutorial Muenchen, Robert A. and Joseph Hilbe. 2010. R for Stata Users http://link.springer.com/book/10.1007%2F978-1-4419-1318-0. Useful, although R has changed a surprisingly large amount in the last four years. For example, this does not include RStudio. Note that if you’re unaware, almost all Springer books are available through the library Oscar Torres-Reyna, “Getting Started in R~Stata Notes on Exploring Data” http://www.princeton.edu/~otorres/RStata.pdf. "],
["formatting-tables.html", "Chapter 6 Formatting Tables 6.1 Overview of Packages 6.2 Summary Statistic Table Example 6.3 Regression Table Example", " Chapter 6 Formatting Tables 6.1 Overview of Packages R has multiple packages and functions for directly producing formatted tables for LaTeX, HTML, and other output formats. Given the See the Reproducible Research Task View for an overview of various options. xtable is a general purpose package for creating LaTeX, HTML, or plain text tables in R. texreg is more specifically geared to regression tables. It also outputs results in LaTeX (texreg), HTML (texreg), and plain text. The packages stargazer and apsrtable are other popular packages for formatting regression output. However, they are less-well maintained and have less functionality than texreg. For example, apsrtable hasn’t been updated since 2012, stargazer since 2015. The texreg vignette is a good introduction to texreg, and also discusses the These blog posts by Will Lowe cover many of the options. Additionally, for simple tables, knitr, the package which provides the heavy lifting for R markdown, has a function knitr. knitr also has the ability to customize how R objects are printed with the knit_print function. Other notable packages are: pander creates output in markdown for export to other formats. tables uses a formula syntax to define tables ReportR has the most complete support for creating Word documents, but is likely too much. For a political science perspective on why automating the research process is important see: Nicholas Eubank Embrace Your Fallibility: Thoughts on Code Integrity, based on this article Matthew Gentzkow Jesse M. Shapiro.Code and Data for the Social Sciences: A Practitioner’s Guide. March 10, 2014. Political Methodologist issue on Workflow Management 6.2 Summary Statistic Table Example The xtable package has methods to convert many types of R objects to tables. library(&quot;gapminder&quot;) gapminder_summary &lt;- gapminder %&gt;% # Keep numeric variables select_if(is.numeric) %&gt;% # gather variables gather(variable, value) %&gt;% # Summarize by variable group_by(variable) %&gt;% # summarise all columns summarise(n = sum(!is.na(value)), `Mean` = mean(value), `Std. Dev.` = sd(value), `Median` = median(value), `Min.` = min(value), `Max.` = max(value)) gapminder_summary ## # A tibble: 4 × 7 ## variable n Mean `Std. Dev.` Median Min. ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 gdpPercap 1704 7.215327e+03 9.857455e+03 3531.8470 241.1659 ## 2 lifeExp 1704 5.947444e+01 1.291711e+01 60.7125 23.5990 ## 3 pop 1704 2.960121e+07 1.061579e+08 7023595.5000 60011.0000 ## 4 year 1704 1.979500e+03 1.726533e+01 1979.5000 1952.0000 ## # ... with 1 more variables: Max. &lt;dbl&gt; Now that we have a data frame with the table we want, use xtable to create it: library(&quot;xtable&quot;) foo &lt;- xtable(gapminder_summary, digits = 0) %&gt;% print(type = &quot;html&quot;, html.table.attributes = &quot;&quot;, include.rownames = FALSE, format.args = list(big.mark = &quot;,&quot;)) variable n Mean Std. Dev. Median Min. Max. gdpPercap 1,704 7,215 9,857 3,532 241 113,523 lifeExp 1,704 59 13 61 24 83 pop 1,704 29,601,212 106,157,897 7,023,596 60,011 1,318,683,096 year 1,704 1,980 17 1,980 1,952 2,007 Note that there we two functions to get HTML. The function xtable creates an xtable R object, and the function xtable (called as print()), which prints the xtable object as HTML (or LaTeX). The default HTML does not look nice, and would need to be formatted with CSS. If you are copy and pasting it into Word, you would do some post-processing cleanup anyways. Another alternative is the knitr function in the knitr package, which outputs R markdown tables. knitr::kable(gapminder_summary) variable n Mean Std. Dev. Median Min. Max. gdpPercap 1704 7.215327e+03 9.857455e+03 3531.8470 241.1659 1.135231e+05 lifeExp 1704 5.947444e+01 1.291711e+01 60.7125 23.5990 8.260300e+01 pop 1704 2.960121e+07 1.061579e+08 7023595.5000 60011.0000 1.318683e+09 year 1704 1.979500e+03 1.726533e+01 1979.5000 1952.0000 2.007000e+03 This is useful for producing quick tables. Finally, htmlTables package unsurprisingly produces HTML tables. library(&quot;htmlTable&quot;) htmlTable(txtRound(gapminder_summary, 0), align = &quot;lrrrr&quot;) variable n Mean Std. Dev. Median Min. Max. 1 gdpPercap 1704 7 10 3532 241 1 2 lifeExp 1704 6 1 61 24 8 3 pop 1704 3 1 7023596 60011 1 4 year 1704 2 2 1980 1952 2 It has more features for producing HTML tables than xtable, but does not output LaTeX. 6.3 Regression Table Example library(&quot;tidyverse&quot;) library(&quot;texreg&quot;) We will run several regression models with the Duncan data Prestige &lt;- car::Prestige Since I’m running several regressions, I will save them to a list. If you know that you will be creating multiple objects, and programming with them, always put them in a list. First, create a list of the regression formulas, formulae &lt;- list( prestige ~ type, prestige ~ income, prestige ~ education, prestige ~ type + education + income ) Write a function to run a single model, Now use map to run a regression with each of these formulae, and save them to a list, prestige_mods &lt;- map(formulae, ~ lm(.x, data = Prestige, model = FALSE)) This is a list of lm objects, map(prestige_mods, class) ## [[1]] ## [1] &quot;lm&quot; ## ## [[2]] ## [1] &quot;lm&quot; ## ## [[3]] ## [1] &quot;lm&quot; ## ## [[4]] ## [1] &quot;lm&quot; We can look at the first model, prestige_mods[[1]] ## ## Call: ## lm(formula = .x, data = Prestige, model = FALSE) ## ## Coefficients: ## (Intercept) typeprof typewc ## 35.527 32.321 6.716 Now we can format the regression table in HTML using htmlreg. The first argument of htmlreg is a list of models: htmlreg(prestige_mods) Statistical models Model 1 Model 2 Model 3 Model 4 (Intercept) 35.53*** 27.14*** -10.73** -0.62 (1.43) (2.27) (3.68) (5.23) typeprof 32.32*** 6.04 (2.23) (3.87) typewc 6.72** -2.74 (2.44) (2.51) income 0.00*** 0.00*** (0.00) (0.00) education 5.36*** 3.67*** (0.33) (0.64) R2 0.70 0.51 0.72 0.83 Adj. R2 0.69 0.51 0.72 0.83 Num. obs. 98 102 102 98 RMSE 9.50 12.09 9.10 7.09 p &lt; 0.001, p &lt; 0.01, p &lt; 0.05 By default, htmlreg() prints out HTML, which is exactly what I want in an R markdown document. To save the output to a file, specify a non-null file argument. For example, to save the table to the file prestige.html, htmlreg(prestige_mods, file = &quot;prestige.html&quot;) Since this function outputs HTML directly to the console, it can be hard to tell what’s going on. If you want to preview the table in RStudio while working on it, this snippet of code uses htmltools package to do so: library(&quot;htmltools&quot;) htmlreg(prestige_mods) %&gt;% HTML() %&gt;% browsable() The htmlreg function has many options to adjust the table formatting. Below, I clean up the table. I remove stars using stars = NULL. It is a growing convention to avoid the use of stars indicating significance in regression tables (see AJPS and Political Analysis guidelines). The arguments doctype, html.tag, head.tag, body.tag control what sort of HTML is created. Generally all these functions (whether LaTeX or HTML output) have some arguments that determine whether it is creating a standalone, complete document, or a fragment that will be copied into another dcoument. The arguments include.rsquared, include.adjrs, and include.nobs are passed to the function extract() which determines what information the texreg package extracts from a model to put into the table. I get rid of \\(R^2\\), but keep adjusted \\(R^2\\), and the number of observations. library(&quot;stringr&quot;) coefnames &lt;- c(&quot;Intercept&quot;, &quot;Professional&quot;, &quot;Working Class&quot;, &quot;Income&quot;, &quot;Education&quot;) note &lt;- &quot;OLS regressions with prestige as the response variable.&quot; htmlreg(prestige_mods, stars = NULL, custom.model.names = str_c(&quot;(&quot;, seq_along(prestige_mods), &quot;)&quot;), custom.coef.names = coefnames, custom.note = str_c(&quot;Note: &quot;, note), omit.coef = &quot;(Intercept)&quot;, caption.above = TRUE, caption = &quot;Regressions of Occupational Prestige&quot;, # better for markdown doctype = FALSE, html.tag = FALSE, head.tag = FALSE, body.tag = FALSE, # passed to extract() method for &quot;lm&quot; include.adjr = TRUE, include.rsquared = FALSE, include.rmse = FALSE, include.nobs = TRUE) Regressions of Occupational Prestige (1) (2) (3) (4) Professional 32.32 6.04 (2.23) (3.87) Working Class 6.72 -2.74 (2.44) (2.51) Income 0.00 0.00 (0.00) (0.00) Education 5.36 3.67 (0.33) (0.64) Adj. R2 0.69 0.51 0.72 0.83 Num. obs. 98 102 102 98 Note: OLS regressions with prestige as the response variable. Once you find a set of options that are common across your tables, make a function so you con’t need to retype them. my_reg_table &lt;- function(mods, ..., note = NULL) { htmlreg(mods, stars = NULL, custom.note = if (!is.null(note)) str_c(&quot;Note: &quot;, note) else NULL, caption.above = TRUE, # better for markdown doctype = FALSE, html.tag = FALSE, head.tag = FALSE) } my_reg_table(prestige_mods, custom.model.names = str_c(&quot;(&quot;, seq_along(prestige_mods), &quot;)&quot;), custom.coef.names = coefnames, note = note, # put intercept at the bottom reorder.coef = c(2, 3, 4, 5, 1), caption = &quot;Regressions of Occupational Prestige&quot;) Statistical models Model 1 Model 2 Model 3 Model 4 (Intercept) 35.53 27.14 -10.73 -0.62 (1.43) (2.27) (3.68) (5.23) typeprof 32.32 6.04 (2.23) (3.87) typewc 6.72 -2.74 (2.44) (2.51) income 0.00 0.00 (0.00) (0.00) education 5.36 3.67 (0.33) (0.64) R2 0.70 0.51 0.72 0.83 Adj. R2 0.69 0.51 0.72 0.83 Num. obs. 98 102 102 98 RMSE 9.50 12.09 9.10 7.09 Note: OLS regressions with prestige as the response variable. Note that I didn’t include every option in my_reg_table, only those arguments that will be common across tables. I use ... to pass arguments to htmlreg. Then when I call my_reg_table the only arguments are those specific to the content of the table, not the formatting, making it easier to understand what each table is saying. Of course, texreg also produces LaTeX output, with the function texreg. Almost all the options are the same as htmlreg. "],
["reproducible-research.html", "Chapter 7 Reproducible Research", " Chapter 7 Reproducible Research "],
["writing-resources.html", "Chapter 8 Writing Resources 8.1 Writing and Organizing Papers 8.2 Finding Research Ideas 8.3 Replications", " Chapter 8 Writing Resources 8.1 Writing and Organizing Papers Here are a few useful resources for writing papers: Chris Adolph. Writing Empirical Papers: 6 Rules &amp; 12 Recommendations Barry R. Weingast. 2015. Caltech Rules for Writing Papers: How to Structure Your Paper and Write an Introduction The Science of Scientific Writing American Scientist Deidre McCloskey. Economical Writing William Thompson. A Guide for the Young Economist. “Chapter 2: Writing Papers.” Stephen Van Evera. Guide to Methods for Students of Political Science. Appendix. Joseph M. Williams and Joseph Bizup. Style: Lessons in Clarity and Grace Strunk and White. The Elements of Style Chicago Manual of Style and APSA Style Manual for Political Science for editorial and style issues. How to construct a Nature summary paragraph. Though specifi to Nature is good advice for structuring abstracts or introductions. Ezra Klein. How researchers are terrible communications, and how they can do better. The advice in the AJPS Instructions for Submitting Authors is a concise description of how to write an abstract: The abstract should provide a very concise descriptive summary of the research stream to which the manuscript contributes, the specific research topic it addresses, the research strategy employed for the analysis, the results obtained from the analysis, and the implications of the findings. Concrete Advice for Writing Informative Abstracts and pHow to Carefully Choose Useless Titles for Academic Writing](http://www.socialsciencespace.com/2014/03/how-to-carefully-choose-useless-titles-for-academic-writing/) 8.2 Finding Research Ideas Paul Krugman How I Work. His basic rules are Listen to the Gentiles Question the question Dare to be silly Simplify, simplify See Hal Varian. How to build an Economic Model in your spare time The first step is to get an idea. This is not all that hard to do. The tricky part is to get a good idea. The way you do this is to come up with lots and lots of ideas and throw out all the ones that aren’t good. But where to get ideas, that’s the question. Most graduate students are convinced that the way you get ideas is to read journal articles. But in my experience journals really aren’t a very good source of original ideas. You can get lots of things from journal articles—technique, insight, even truth. But most of the time you will only get someone else’s ideas. … My suggestion is rather different: I think that you should look for your ideas outside the academic journals—in newspapers, in magazines, in conversations, and in TV and radio programs. … Conversations, especially with people in business, are often very fruitful. Commerce is conducted in many ways, and most of them have never been subjected to a serious economic analysis. … In many cases your ideas can come from your own life and experiences. … Before you start trying to decide whether your idea is correct, you should stop to ask whether it is interesting. If it isn’t interesting, no one will care whether it is correct or not. So try it out on a few people—see if they think that it is worth pursuing. What would follow from this idea if it is correct? … The first thing that most graduate students do is they rush to the literature to see if someone else had this idea already. However, my advice is to wait a bit before you look at the literature. Eventually you should do a thorough literature review, of course, but I think that you will do much better if you work on your idea for a few weeks before doing a systematic literature search…. Greg Mankiw, My Rules of Thumb: Coming up with ideas is the hardest and least controllable part of the research process. It is somewhat easier if you have broad interests. Most obviously, broad interests give you more opportunities for success. A miner is more likely to strike gold if he looks over a large field than over the same field over and over again Also the links in this Greg Mankiw Advice for Grad Students 8.3 Replications Gary King has advice on how to turn a replication into a publishable paper: Gary King How to Write a Publishable Paper as a Class Project Gary King. 2006. “Publication, Publication.” PS: Political Science and Politics. Political Science Should Not Stop Young Researchers from Replicating from the Political Science Replication blog. And see the examples of students replications from his Harvard course at https://politicalsciencereplication.wordpress.com/ Famous replications. David Broockman, Joahua Kalla, and Peter Aronow. 2015. Irregularities in LaCour (2014). Homas Herndon, Michael Ash &amp; Robert Pollin (2013). Does High Public Debt Consistently Stifle Economic Growth? A Critique of Reinhart and Rogoff. Working Paper Series 322. Political Economy Research Institute. [URL] However, although those replications are famous for finding fraud or obvious errors in the analysis, replications can lead to extensions and generate new ideas. This was the intent of Brookman, Kalla, and Aronow when starting the replication. "]
]
